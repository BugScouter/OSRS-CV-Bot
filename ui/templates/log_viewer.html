<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Log Viewer</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            /* Dark theme colors matching the main UI */
            --primary-color: #4dabf7;
            --secondary-color: #6c757d;
            --success-color: #51cf66;
            --warning-color: #ffd43b;
            --danger-color: #ff6b6b;
            --info-color: #74c0fc;
            
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #404040;
            
            --text-color: #f8f9fa;
            --text-muted: #adb5bd;
            --text-secondary: #ced4da;
            
            --border-color: #495057;
            --card-bg: #2d2d2d;
            --sidebar-bg: #252526;
            --code-bg: #1e1e1e;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
        }

        .log-container {
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        .log-sidebar {
            width: 280px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 1rem;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
        }
        
        .log-sidebar.collapsed {
            margin-left: -280px;
        }

        .log-sidebar h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .filter-group {
            margin-bottom: 1.5rem;
        }

        .filter-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .filter-controls h4 {
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0;
            color: var(--text-secondary);
        }
        
        .btn-group-sm .btn {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
        }

        .form-check {
            margin-bottom: 0.25rem;
        }

        .form-check-label {
            font-size: 0.85rem;
            color: var(--text-color);
        }

        /* Main panel */
        .log-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background-color: var(--card-bg);
            border-bottom: 1px solid var(--border-color);
        }
        
        .log-header-left, .log-header-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .log-header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0;
            color: var(--text-color);
        }

        .connection-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--danger-color);
            transition: background-color 0.3s ease;
        }
        
        .connection-indicator.connected {
            background-color: var(--success-color);
        }

        .logs {
            flex: 1;
            overflow-y: auto;
            background-color: var(--code-bg);
            padding: 1rem;
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.125rem 0;
            word-wrap: break-word;
        }

        .log-entry .timestamp {
            color: var(--text-muted);
            margin-right: 0.5rem;
        }

        .log-entry .logger-name {
            color: #c586c0;
            margin-right: 0.5rem;
            font-weight: 500;
        }

        .log-entry .level {
            margin-right: 0.5rem;
            font-weight: 600;
        }

        .log-entry.DEBUG .level { color: #9cdcfe; }
        .log-entry.INFO .level { color: #dcdcaa; }
        .log-entry.WARNING .level { color: #d7ba7d; }
        .log-entry.ERROR .level { color: #f44747; }
        .log-entry.CRITICAL .level { color: #f44747; font-weight: bold; }

        .log-entry .message {
            color: var(--text-color);
        }

        /* Scrollbar styling */
        .logs::-webkit-scrollbar, .log-sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .logs::-webkit-scrollbar-thumb, .log-sidebar::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 4px;
        }
        .logs::-webkit-scrollbar-track, .log-sidebar::-webkit-scrollbar-track {
            background-color: var(--bg-secondary);
        }

        /* Loading state */
        .loading {
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Button styling to match theme */
        .btn-outline-light {
            color: var(--text-color);
            border-color: var(--border-color);
        }
        
        .btn-outline-light:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--primary-color);
            color: var(--text-color);
        }
    </style>
</head>
<body>
    <div class="log-container">
        <!-- Sidebar -->
        <aside class="log-sidebar" id="sidebar">
            <h3><i class="fas fa-filter"></i> Filters</h3>

            <!-- Logger Name Filter -->
            <div class="filter-group">
                <div class="filter-controls">
                    <h4>Logger Names</h4>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-light" id="selectAllLoggers">All</button>
                        <button class="btn btn-outline-light" id="selectNoneLoggers">None</button>
                    </div>
                </div>
                <div id="logger-checkboxes" class="loading">
                    Loading loggers...
                </div>
            </div>

            <!-- Log Level Filter -->
            <div class="filter-group">
                <div class="filter-controls">
                    <h4>Log Levels</h4>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-light" id="selectAllLevels">All</button>
                        <button class="btn btn-outline-light" id="selectNoneLevels">None</button>
                    </div>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="DEBUG" id="levelDEBUG" checked>
                    <label class="form-check-label" for="levelDEBUG">DEBUG</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="INFO" id="levelINFO" checked>
                    <label class="form-check-label" for="levelINFO">INFO</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="WARNING" id="levelWARNING" checked>
                    <label class="form-check-label" for="levelWARNING">WARNING</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="ERROR" id="levelERROR" checked>
                    <label class="form-check-label" for="levelERROR">ERROR</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="CRITICAL" id="levelCRITICAL" checked>
                    <label class="form-check-label" for="levelCRITICAL">CRITICAL</label>
                </div>
            </div>
        </aside>

        <!-- Main Panel -->
        <section class="log-main">
            <div class="log-header">
                <div class="log-header-left">
                    <button class="btn btn-outline-light btn-sm" id="sidebarToggle">
                        <i class="fas fa-bars"></i>
                    </button>
                    <h1>Bot Logs</h1>
                    <div class="connection-indicator" id="connectionIndicator" title="WebSocket Connection Status"></div>
                </div>
                <div class="log-header-right">
                    <button class="btn btn-outline-light btn-sm" id="clearLogsBtn" title="Clear Logs">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
            </div>
            <div class="logs" id="logsContainer">
                <div class="loading">Connecting to log server...</div>
            </div>
        </section>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Configuration
        function getUrlParam(name, defaultValue) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name) || defaultValue;
        }

        const host = getUrlParam('host', 'localhost');

        // State
        let availableLoggers = [];
        let subscribedLoggers = new Set();
        let allowedLevels = new Set(['DEBUG','INFO','WARNING','ERROR','CRITICAL']);
        let isConnected = false;
        
        // DOM References
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const connectionIndicator = document.getElementById('connectionIndicator');
        const loggerCheckboxesContainer = document.getElementById('logger-checkboxes');
        const logsContainer = document.getElementById('logsContainer');
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        const selectAllLoggers = document.getElementById('selectAllLoggers');
        const selectNoneLoggers = document.getElementById('selectNoneLoggers');
        const selectAllLevels = document.getElementById('selectAllLevels');
        const selectNoneLevels = document.getElementById('selectNoneLevels');
        
        // LocalStorage Keys
        const LS_SIDEBAR_STATE = 'log_viewer_sidebar_state';
        const LS_SUBSCRIBED_LOGGERS = 'log_viewer_subscribed_loggers';
        const LS_ALLOWED_LEVELS = 'log_viewer_allowed_levels';
        
        // Initialize UI state from localStorage
        function initFromLocalStorage() {
            // Initialize sidebar state
            if (localStorage.getItem(LS_SIDEBAR_STATE) === 'collapsed') {
                sidebar.classList.add('collapsed');
            }
            
            // Initialize logger subscriptions
            try {
                const savedLoggers = localStorage.getItem(LS_SUBSCRIBED_LOGGERS);
                if (savedLoggers) {
                    subscribedLoggers = new Set(JSON.parse(savedLoggers));
                }
            } catch (e) {
                console.error('Error loading subscribed loggers from localStorage:', e);
            }
            
            // Initialize log levels
            try {
                const savedLevels = localStorage.getItem(LS_ALLOWED_LEVELS);
                if (savedLevels) {
                    allowedLevels = new Set(JSON.parse(savedLevels));
                    updateLevelCheckboxes();
                }
            } catch (e) {
                console.error('Error loading allowed levels from localStorage:', e);
            }
        }
        
        function updateLevelCheckboxes() {
            const levelCheckboxes = document.querySelectorAll('input[type="checkbox"][id^="level"]');
            levelCheckboxes.forEach(cb => {
                cb.checked = allowedLevels.has(cb.value);
            });
        }
        
        // Load state from localStorage
        initFromLocalStorage();
        
        // WebSocket Setup
        let socket = null;
        let reconnectInterval = null;
        let receivedMessagesCache = new Set();
        
        async function connectWebSocket() {
            if (socket) {
                try {
                    socket.close();
                } catch (e) {
                    console.log('Error closing existing socket:', e);
                }
            }
            
            try {
                // Get the actual logging port from the server
                const response = await fetch('/api/logging/port');
                const data = await response.json();
                const port = data.port;
                
                if (!port) {
                    console.error('WebSocket server port not available yet');
                    connectionIndicator.classList.remove('connected');
                    connectionIndicator.title = 'WebSocket server not ready';
                    // Retry after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                    return;
                }
                
                const wsUrl = `ws://${host}:${port}`;
                console.log(`Connecting to WebSocket on port ${port}`);
                socket = new WebSocket(wsUrl);
                
                setupWebSocketHandlers(port);
                
            } catch (error) {
                console.error('Failed to get logging port:', error);
                connectionIndicator.classList.remove('connected');
                connectionIndicator.title = 'Failed to connect to log server';
                // Retry after 5 seconds
                setTimeout(connectWebSocket, 5000);
            }
        }
        
        function setupWebSocketHandlers(port) {
            
            socket.addEventListener('open', () => {
                console.log(`WebSocket connected to port ${port}`);
                isConnected = true;
                connectionIndicator.classList.add('connected');
                connectionIndicator.title = `Connected to ${host}:${port}`;
                receivedMessagesCache.clear();
                
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
                
                // Clear loading message
                logsContainer.innerHTML = '';
                
                // Request the list of loggers
                socket.send(JSON.stringify({command: 'get_loggers'}));
                
                // Resubscribe if we had existing subscriptions
                if (subscribedLoggers.size > 0) {
                    sendSubscribeRequest();
                }
            });
            
            socket.addEventListener('message', event => {
                try {
                    const msg = JSON.parse(event.data);
                    handleServerMessage(msg);
                } catch (err) {
                    console.error('Invalid JSON from server:', event.data);
                }
            });
            
            socket.addEventListener('close', () => {
                console.warn('WebSocket closed');
                isConnected = false;
                connectionIndicator.classList.remove('connected');
                connectionIndicator.title = 'Disconnected - trying to reconnect...';
                
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(() => {
                        console.log('Attempting to reconnect...');
                        connectWebSocket();
                    }, 3000);
                }
            });
            
            socket.addEventListener('error', (error) => {
                console.error(`WebSocket error on port ${port}:`, error);
                isConnected = false;
                connectionIndicator.classList.remove('connected');
                connectionIndicator.title = 'Connection error';
                
                // Retry connection after 5 seconds
                setTimeout(connectWebSocket, 5000);
            });
        }
        }
        
        // Initial connection
        connectWebSocket();

        // Handle Incoming Messages
        function handleServerMessage(msg) {
            switch (msg.type) {
                case 'loggers_list':
                    populateLoggerFilter(msg.loggers);
                    break;

                case 'log':
                    renderLogEntry(msg);
                    break;

                case 'error':
                    console.error('Server error:', msg.error_code, msg.message);
                    break;

                default:
                    console.warn('Unknown message type:', msg);
            }
        }

        // Populate Logger-Name Checkboxes
        function populateLoggerFilter(loggers) {
            availableLoggers = loggers;
            loggerCheckboxesContainer.innerHTML = '';

            loggers.sort();
            
            const useLocalStorage = subscribedLoggers.size > 0;

            loggers.forEach(name => {
                const div = document.createElement('div');
                div.className = 'form-check';

                const cb = document.createElement('input');
                cb.className = 'form-check-input';
                cb.type = 'checkbox';
                cb.value = name;
                cb.id = `logger${name.replace(/[^a-zA-Z0-9]/g, '')}`;
                cb.checked = useLocalStorage ? subscribedLoggers.has(name) : true;
                cb.addEventListener('change', onLoggerCheckboxChange);

                const label = document.createElement('label');
                label.className = 'form-check-label';
                label.htmlFor = cb.id;
                label.textContent = name;

                if (!useLocalStorage) {
                    subscribedLoggers.add(name);
                }

                div.appendChild(cb);
                div.appendChild(label);
                loggerCheckboxesContainer.appendChild(div);
            });

            sendSubscribeRequest();
        }

        // When a Logger-Name Checkbox Changes
        function onLoggerCheckboxChange(evt) {
            const name = evt.target.value;
            if (evt.target.checked) {
                subscribedLoggers.add(name);
            } else {
                subscribedLoggers.delete(name);
            }
            
            localStorage.setItem(LS_SUBSCRIBED_LOGGERS, JSON.stringify(Array.from(subscribedLoggers)));
            sendSubscribeRequest();
        }

        // Send Subscribe Command to Server
        function sendSubscribeRequest() {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            const arr = Array.from(subscribedLoggers);
            socket.send(JSON.stringify({command: 'subscribe', loggers: arr}));
        }

        // Render a Single Log Entry
        function renderLogEntry({timestamp, logger_name, level, message}) {
            if (!allowedLevels.has(level)) return;
            
            const msgSignature = `${timestamp}:${logger_name}:${level}:${message}`;
            
            if (receivedMessagesCache.has(msgSignature)) {
                return;
            }
            
            receivedMessagesCache.add(msgSignature);
            if (receivedMessagesCache.size > 1000) {
                receivedMessagesCache.clear();
            }

            const entry = document.createElement('div');
            entry.classList.add('log-entry', level);

            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('timestamp');
            timestampSpan.textContent = `[${timestamp}]`;
            entry.appendChild(timestampSpan);

            const loggerSpan = document.createElement('span');
            loggerSpan.classList.add('logger-name');
            loggerSpan.textContent = logger_name;
            entry.appendChild(loggerSpan);

            const levelSpan = document.createElement('span');
            levelSpan.classList.add('level');
            levelSpan.textContent = level;
            entry.appendChild(levelSpan);

            const messageSpan = document.createElement('span');
            messageSpan.classList.add('message');
            messageSpan.textContent = ` â€“ ${message}`;
            entry.appendChild(messageSpan);

            logsContainer.appendChild(entry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
            
            // Keep only last 1000 entries
            while (logsContainer.children.length > 1000) {
                logsContainer.removeChild(logsContainer.firstChild);
            }
        }

        // Level Filter Handling
        const levelCheckboxes = document.querySelectorAll('input[type="checkbox"][id^="level"]');
        levelCheckboxes.forEach(cb => {
            cb.addEventListener('change', () => {
                allowedLevels.clear();
                levelCheckboxes.forEach(lvlCb => {
                    if (lvlCb.checked) allowedLevels.add(lvlCb.value);
                });
                
                localStorage.setItem(LS_ALLOWED_LEVELS, JSON.stringify(Array.from(allowedLevels)));
            });
        });

        // Event Listeners
        clearLogsBtn.addEventListener('click', () => {
            logsContainer.innerHTML = '';
        });
        
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            localStorage.setItem(
                LS_SIDEBAR_STATE, 
                sidebar.classList.contains('collapsed') ? 'collapsed' : 'expanded'
            );
        });
        
        selectAllLoggers.addEventListener('click', () => {
            const checkboxes = loggerCheckboxesContainer.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                subscribedLoggers.add(cb.value);
            });
            localStorage.setItem(LS_SUBSCRIBED_LOGGERS, JSON.stringify(Array.from(subscribedLoggers)));
            sendSubscribeRequest();
        });
        
        selectNoneLoggers.addEventListener('click', () => {
            const checkboxes = loggerCheckboxesContainer.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                subscribedLoggers.delete(cb.value);
            });
            localStorage.setItem(LS_SUBSCRIBED_LOGGERS, JSON.stringify(Array.from(subscribedLoggers)));
            sendSubscribeRequest();
        });
        
        selectAllLevels.addEventListener('click', () => {
            levelCheckboxes.forEach(cb => {
                cb.checked = true;
                allowedLevels.add(cb.value);
            });
            localStorage.setItem(LS_ALLOWED_LEVELS, JSON.stringify(Array.from(allowedLevels)));
        });
        
        selectNoneLevels.addEventListener('click', () => {
            levelCheckboxes.forEach(cb => {
                cb.checked = false;
                allowedLevels.delete(cb.value);
            });
            localStorage.setItem(LS_ALLOWED_LEVELS, JSON.stringify(Array.from(allowedLevels)));
        });

        // Periodic Ping
        setInterval(() => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({command: 'ping'}));
            }
        }, 30000);
    </script>
</body>
</html>